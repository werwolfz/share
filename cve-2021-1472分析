#### Netlogon特权提升漏洞(cve-2020-1472)复现和分析：

一般适用于win>=2008
Netlogon远程协议([MS-NRPC](https://docs.microsoft.com/zh-cn/openspecs/windows_protocols/ms-nrpc/ff8f970f-3e37-40f7-bd4b-af7336e4792f)))是一种在win域控上使用的RPC接口。RPC接口可通过TCP端口(通过域控制器的portmapper服务分配的动态端口)来实现或通过端口445上的SMB管道来实现，该RPC接口由加入域的主机独占使用。

最常见用于使用户通过NTLM协议登录服务器或更新域密码。

cve-2020-1472漏洞分析：主要用于提权.
Netlogon身份认证协议使用挑战-响应机制，其加密算法为AES-CFB8，且IV默认全零，导致该漏洞产生。使得攻击者仅需较少次数的尝试就能将域控密码置空。 且服务器端认证次数没做限制。

对应补丁：KB4571719



poc：
https://github.com/SecuraBV/CVE-2020-1472
https://github.com/dirkjanm/CVE-2020-1472
https://github.com/mstxq17/cve-2020-1472







AES是一种区块加密算法或标志.

AES-CFB8加密算法：对称加密算法(加密解密使用同一个密钥).
常见有四种模式：ECB、CBC、CFB、OFB

流加密：即对称加密.
面向字符的应用程序的加密需流加密法，故可以使用加密反馈模式.
该模式下，数据加密的单元为8位.
一般的块通常为64位.

CFB(Cipher Feedback Mode)：加密反馈模式







Netlogon协议是微软提供的一套域访问认证协议，不同于大部分rpc服务，该协议使用的并不是典型的微软认证方式如NTLM或Kerberos，该协议的通信流程如下：

![q1](.\imgs\q1.png)



客户端和服务器端(DC)互发一个8字节随机数给到对方，再使用密钥派生函数(KDF)以secret和challenges为参数进行加密，得到密文。

secret：客户端的密码hash.

challenges：以client_challenge和server_challenge为参数计算后的结果。





Netlogon session初始化由client完成，client和sever再交换随机的8字节随机数(称为challenge)，然后它们再通过使用密钥派生函数KDF(Key derivation function)以client_challenge、server_challenge、client的账户密码hash(即secret)为参数计算得到session key. 

client使用该session key进行计算再得到client credential.

server进行相同的流程或步骤得到credential，若两个credential结果相同，则判定client有正确的账号密码及session key，则验证通过。





在认证握手阶段，client和server可以协商是否对subsequent messages(后续消息)进行加密和密码学认证(称为seal  and sign)，主要是为了抵御网络层的攻击。

若协商不使用加密，一些执行重要action的Netlogon call(Netlogon协议网络登录调用)仍会包含一个authticator值，该值也是使用session key计算得到的。







client和server用于生成credential的加密原语由ComputeNetlogonCredential()函数实现，该函数接收一个8字节长度的输入，然后使用session key对其进行转换，输出8字节长度的数据。

保证安全性的基本思路：

不知道sesison key的攻击者即使知道输入也无法计算或猜测出输出。









 若client和server之间协商为AES，则使用AES-128加密算法，使用0作为初始化矢量(windows中IV被设置为0)并在8位CFB模式下计算Netlogon凭据。 其计算过程大致如下：

```
 ComputeNetlogonCredential(Input, Sk, Output)
       SET IV = 0
       CALL AesEncrypt(Input, Sk, IV, Output)
```

即采用的AES-CFB8加密算法(在8位CFB模式下的AES-128加密算法，且初始化矢量(IV)为0).







大多数的域控使用的都是AES加密方案。







##### AES-CFB8算法的计算过程大致如下：

1.首先，在明文plaintext前面加上16字节长度的Initialistation Vector(VI)

2.对修改后的VI+plaintext进行AES运算，获取其结果的第1个字节(8bit)

3.使用获取的第1个字节和plaintext的下一个字节进行异或操作

上述过程示意图如下：

<img src=".\imgs\q2.png" alt="q2" style="zoom:80%;" />





正常来说，每次IV应该是一个不同的随机值，但在windows中IV被设置为全0的16字节数据。

session key作为AES的输入对数据进行加密。session key依赖于secret、server_challenge，而secret固定(client和server端都有存)，故每次server_challenge不同则session key基本上都会不同。故则有1/256的概率使得产生的该session key对全0的IV进行AES加密得到的第一个字节为全0(即\x00).



即使不知道session key，也可以指定加密字符串为8字节的0，指定计算结果也为8字节的0，故server端(DC端)有1/256的概率对8字节的0加密得到的结果也为8字节的0，故使得验证通过。





过程类似如下：

<img src=".\imgs\q3.png" alt="q3" style="zoom:80%;" />



此法比较通用，应该是随机分布的。





漏洞核心：一个全0的输入导致一个全0的输出。







##### 绕过signing和sealing：即绕过对后续消息进行加密验证。

Netlogon的传输加密机制(RPC signing and sealing)中若要对消息加密，则需知道session key的值。

但singing和sealing是可选项，故可以通过在NetrServerAuthenticate3()函数中取消设置对应的标志位来关闭这些选项。在现代client认证中，默认是拒绝未设置这两个flag的对server的连接请求的，但windows中未打KB4571719补丁的server并不拒绝。故攻击时手动关闭这两个flag选项即可。





##### 欺骗调用：

即使禁用了加密，每个执行某些敏感操作的函数调用也必须包含一个Authenticator值(即ClientStoredCredential值)，该值计算过程如下：

```
 SET TimeNow = current time;
 SET ClientAuthenticator.Timestamp = TimeNow; 
 SET ClientStoredCredential = ClientStoredCredential + TimeNow;
 CALL ComputeNetlogonCredential(ClientStoredCredential,
               Session-Key, ClientAuthenticator.Credential);
```



ClientStoredCredential是client维护的一个增量值。 执行握手时，它被会初始化为由client提供的ClientCredential相同的值。故可设置最初的ClientStoredCredential值为0.

TimeStamp为NETLOGON_AUTHENTICATOR结构中的TimeStamp字段，包含当前的Posix时间(时间戳)。 实际上可简单地将其设置为1970年1月1日，即设为0.

故ClientStoredCredential为0、ClientAuthenticator.Credential为0. 故最终值也为0，即：

ComputeNetlogonCredential(0)=0;

故可简单的提供全0的authenticator和全0的TimeStamp来验证第1个调用。





##### 修改计算机的AD域密码：

经过前面几步，已经可以向任何计算机发起Netlogon(网络登录)的请求。

思路1：调用NetrServerPasswordGet()函数来获取计算机密码的NTLM哈希。但NTLM哈希使用的另一种加密方式，故放弃。

思路2：使用NetrServerPasswordSet2()函数，其主要作用是为client设置新的计算机密码，函数原型如下：

```
 NTSTATUS NetrServerPasswordSet2(
   [in, unique, string] LOGONSRV_HANDLE PrimaryName,
   [in, string] wchar_t* AccountName,
   [in] NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
   [in, string] wchar_t* ComputerName,
   [in] PNETLOGON_AUTHENTICATOR Authenticator,
   [out] PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
   [in] PNL_TRUST_PASSWORD ClearNewPassword
 );
```

分析：

使用了Authenticator，即使用了sesison key对其加密，故可再次使用AES_CFB8和全0的IV进行解决。





plaintext密码结构包含516个字节，最后的4个字节指明了密码长度(字节为单位).

结构中所有不属于密码功能的字节都被视为填充，并且可以是任意值。若提供516个0，则加密结果就是516个0.

即密码为空，密码长度为0.

因为计算机并不禁止设置空密码，则实际上可以使用516个0登录域中的任意一台主机。完成后，则可代表该计算机建立新的Netlogon连接。

流程大致如下：

<img src=".\imgs\q4.png" alt="q4" style="zoom:80%;" />



修改后的密码(空)，其只是设置了AD中的域控的主机账号的密码为空，但实际上AD中的域控的主机账号的原始密码仍存储在本地的注册表中(并没有被修改)，则其无法向AD进行身份验证(因为其提供的密码[本地注册表中]和AD中的主机密码不一致)。



则直接以类似拿到cifs票据的方式连接上该主机，dump hash，最后再从注册表中拿到原始的密码或hash，恢复即可。



原始密码在注册表(`HKLM\SECURITY\Policy\Secrets\$machine.ACC`)中。

域控打开SECURITY文件夹失败则需先赋予该文件夹权限。



使用Impacket的secretsdump.py提取hash：连接上目标主机并通过Directory Replication Service(DRS)协议(目录复制协议)从域中提取出hash.







DCE/RPC(Distributed Computing Environment/Remote Procedure Calls)：是由分散式运算环境(DCE)系统发展出来的远端程序呼(RPC)系统。其可以让分散式运算软件调用远程系统的资源。



EMP(Enterprise Performance Management)：远程管理协议。











##### 流量分析：

1.爆破特征：

发现大量RPC_NETLOGON的请求，且前面都为STATUS_ACCESS_DENIED，即认证失败。

<img src=".\imgs\w1.png" alt="w1" style="zoom:80%;" />





最后认证成功：

<img src=".\imgs\w2.png" alt="w2" style="zoom:80%;" />







在RPC_NETLOGON包之前会有EMP(协商端口等)包：

EMP_REQUEST：协商使用任意的ip、port都行。

![w3](.\imgs\w3.png)





EMP_RESPONSE：使用动态端口，一般是高端口，一般为49152~65535

![w4](.\imgs\w4.png)













过滤规则：

netlogon.opnum == 4 || netlogon.opnum == 26 || netlogon.opnum == 30

(1)发送NetrServerReqChallenge(Opnum 4)请求，攻击者请求和域控服务器建立连接，此时Client Challenge为 0000000000000000b(共4*16bit)，即明文密码：





![w5](.\imgs\w5.png)









(2)返回NetrServerReqChallenge(Opnum 4)响应，域控服务器返回成功，同意建立连接：

![w6](.\imgs\w6.png)





(3)发送NetrServerAuthenticate3(Opnum 26)请求，攻击者向域控服务器请求认证，此时Client Credential为 0000000000000000b(共4*16bit)，即ciphertext(计算后得到的密文)，flags为0x212fffff，表示后续消息不使用session key进行加密交互：

<img src=".\imgs\w7.png" alt="w7" style="zoom:80%;" />





(4)返回NetrServerAuthenticate3(Opnum 26)响应，域控返回STATUS_ACCESS_DENIED(0xc0000022)，认证失败：

![w8](.\imgs\w8.png)





因为认证次数没有限制，故可以多次进行认证，直至服务器端计算出来的密文hash也全是0，则认证通过。

(5)最后认证成功，返回STATUS_SUCCESS：

![w9](.\imgs\w9.png)





(6)发送NetrServerPasswordSet2(30)请求，进行密码重置，通过设置NL_TRUST_PASSWORD结构中的密码和长度为0，设置密码为空：

<img src=".\imgs\w10.png" alt="w10" style="zoom:80%;" />





(7)最终返回NetrServerPasswordSet2(30)响应：

![w11](.\imgs\w11.png)





防御：

1.针对Client Challenge为0000000000000000b作为特征检测。

2.NetrServerAuthenticate3的Negotiation options字段做检测。







##### 补丁分析：

补丁中引入了一个新的设置项：VulnerableChannelAllowList

若为使用安全绑定，除非client处于VulnerableChannelAllowList中，否则server直接拒绝该请求。

若client质询的前5个字节都不唯一(即前5个字节都是相同)，则server必须在不进行后续步骤的情况下使session key协商失败。



